#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class UnitEnum:
  UNKNOWN = 0
  OTHER = 1
  BITS = 2
  BYTES = 3
  KILOBYTES = 4
  MEGABYTES = 5
  MILLISECONDS = 6
  SECONDS = 7
  TIMESTAMP_MILLISECONDS = 8
  TIMESTAMP_SECONDS = 9
  PERCENT = 10

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "OTHER",
    2: "BITS",
    3: "BYTES",
    4: "KILOBYTES",
    5: "MEGABYTES",
    6: "MILLISECONDS",
    7: "SECONDS",
    8: "TIMESTAMP_MILLISECONDS",
    9: "TIMESTAMP_SECONDS",
    10: "PERCENT",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "OTHER": 1,
    "BITS": 2,
    "BYTES": 3,
    "KILOBYTES": 4,
    "MEGABYTES": 5,
    "MILLISECONDS": 6,
    "SECONDS": 7,
    "TIMESTAMP_MILLISECONDS": 8,
    "TIMESTAMP_SECONDS": 9,
    "PERCENT": 10,
  }

class FlapEnum:
  UNKNOWN = 0
  FLAPPING = 1
  NOFLAP = 2

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "FLAPPING",
    2: "NOFLAP",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "FLAPPING": 1,
    "NOFLAP": 2,
  }

class AlarmState:
  UNKNOWN = 0
  OK = 1
  WARNING = 2
  CRITICAL = 6
  DISABLED = 7

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "OK",
    2: "WARNING",
    6: "CRITICAL",
    7: "DISABLED",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "OK": 1,
    "WARNING": 2,
    "CRITICAL": 6,
    "DISABLED": 7,
  }

class Result:
  FAILED = 0
  OK = 1

  _VALUES_TO_NAMES = {
    0: "FAILED",
    1: "OK",
  }

  _NAMES_TO_VALUES = {
    "FAILED": 0,
    "OK": 1,
  }

class CollectorState:
  UP = 0
  DOWN = 1

  _VALUES_TO_NAMES = {
    0: "UP",
    1: "DOWN",
  }

  _NAMES_TO_VALUES = {
    "UP": 0,
    "DOWN": 1,
  }

class VerificationModel:
  ONE = 0
  QUORUM = 1
  ALL = 2

  _VALUES_TO_NAMES = {
    0: "ONE",
    1: "QUORUM",
    2: "ALL",
  }

  _NAMES_TO_VALUES = {
    "ONE": 0,
    "QUORUM": 1,
    "ALL": 2,
  }

class Resolution:
  FULL = 0
  MIN5 = 1
  MIN20 = 2
  MIN60 = 3
  MIN240 = 4
  MIN1440 = 5

  _VALUES_TO_NAMES = {
    0: "FULL",
    1: "MIN5",
    2: "MIN20",
    3: "MIN60",
    4: "MIN240",
    5: "MIN1440",
  }

  _NAMES_TO_VALUES = {
    "FULL": 0,
    "MIN5": 1,
    "MIN20": 2,
    "MIN60": 3,
    "MIN240": 4,
    "MIN1440": 5,
  }


class InvalidQueryException(TException):
  """
  Attributes:
   - why
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'why', None, None, ), # 1
  )

  def __init__(self, why=None,):
    self.why = why

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.why = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidQueryException')
    if self.why is not None:
      oprot.writeFieldBegin('why', TType.STRING, 1)
      oprot.writeString(self.why)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlarmNotFoundException(TException):
  """
  Attributes:
   - why
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'why', None, None, ), # 1
  )

  def __init__(self, why=None,):
    self.why = why

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.why = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlarmNotFoundException')
    if self.why is not None:
      oprot.writeFieldBegin('why', TType.STRING, 1)
      oprot.writeString(self.why)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidRegexException(TException):
  """
  Attributes:
   - why
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'why', None, None, ), # 1
  )

  def __init__(self, why=None,):
    self.why = why

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.why = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidRegexException')
    if self.why is not None:
      oprot.writeFieldBegin('why', TType.STRING, 1)
      oprot.writeString(self.why)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Metric:
  """
  Attributes:
   - metricType
   - valueDbl
   - valueI64
   - valueI32
   - valueStr
   - unitEnum
   - unitOtherStr
   - valueBool
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'metricType', None, None, ), # 1
    (2, TType.DOUBLE, 'valueDbl', None, None, ), # 2
    (3, TType.I64, 'valueI64', None, None, ), # 3
    (4, TType.I32, 'valueI32', None, None, ), # 4
    (5, TType.STRING, 'valueStr', None, None, ), # 5
    (6, TType.I32, 'unitEnum', None, None, ), # 6
    (7, TType.STRING, 'unitOtherStr', None, None, ), # 7
    (8, TType.BOOL, 'valueBool', None, None, ), # 8
  )

  def __init__(self, metricType=None, valueDbl=None, valueI64=None, valueI32=None, valueStr=None, unitEnum=None, unitOtherStr=None, valueBool=None,):
    self.metricType = metricType
    self.valueDbl = valueDbl
    self.valueI64 = valueI64
    self.valueI32 = valueI32
    self.valueStr = valueStr
    self.unitEnum = unitEnum
    self.unitOtherStr = unitOtherStr
    self.valueBool = valueBool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.metricType = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.valueDbl = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.valueI64 = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.valueI32 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.valueStr = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.unitEnum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.unitOtherStr = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.valueBool = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Metric')
    if self.metricType is not None:
      oprot.writeFieldBegin('metricType', TType.BYTE, 1)
      oprot.writeByte(self.metricType)
      oprot.writeFieldEnd()
    if self.valueDbl is not None:
      oprot.writeFieldBegin('valueDbl', TType.DOUBLE, 2)
      oprot.writeDouble(self.valueDbl)
      oprot.writeFieldEnd()
    if self.valueI64 is not None:
      oprot.writeFieldBegin('valueI64', TType.I64, 3)
      oprot.writeI64(self.valueI64)
      oprot.writeFieldEnd()
    if self.valueI32 is not None:
      oprot.writeFieldBegin('valueI32', TType.I32, 4)
      oprot.writeI32(self.valueI32)
      oprot.writeFieldEnd()
    if self.valueStr is not None:
      oprot.writeFieldBegin('valueStr', TType.STRING, 5)
      oprot.writeString(self.valueStr)
      oprot.writeFieldEnd()
    if self.unitEnum is not None:
      oprot.writeFieldBegin('unitEnum', TType.I32, 6)
      oprot.writeI32(self.unitEnum)
      oprot.writeFieldEnd()
    if self.unitOtherStr is not None:
      oprot.writeFieldBegin('unitOtherStr', TType.STRING, 7)
      oprot.writeString(self.unitOtherStr)
      oprot.writeFieldEnd()
    if self.valueBool is not None:
      oprot.writeFieldBegin('valueBool', TType.BOOL, 8)
      oprot.writeBool(self.valueBool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RollupMetric:
  """
  Attributes:
   - numPoints
   - rawSample
   - average
   - variance
   - min
   - max
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numPoints', None, None, ), # 1
    (2, TType.STRUCT, 'rawSample', (Metric, Metric.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'average', (Metric, Metric.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'variance', (Metric, Metric.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'min', (Metric, Metric.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'max', (Metric, Metric.thrift_spec), None, ), # 6
    (7, TType.I64, 'timestamp', None, None, ), # 7
  )

  def __init__(self, numPoints=None, rawSample=None, average=None, variance=None, min=None, max=None, timestamp=None,):
    self.numPoints = numPoints
    self.rawSample = rawSample
    self.average = average
    self.variance = variance
    self.min = min
    self.max = max
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numPoints = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.rawSample = Metric()
          self.rawSample.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.average = Metric()
          self.average.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.variance = Metric()
          self.variance.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.min = Metric()
          self.min.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.max = Metric()
          self.max.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RollupMetric')
    if self.numPoints is not None:
      oprot.writeFieldBegin('numPoints', TType.I64, 1)
      oprot.writeI64(self.numPoints)
      oprot.writeFieldEnd()
    if self.rawSample is not None:
      oprot.writeFieldBegin('rawSample', TType.STRUCT, 2)
      self.rawSample.write(oprot)
      oprot.writeFieldEnd()
    if self.average is not None:
      oprot.writeFieldBegin('average', TType.STRUCT, 3)
      self.average.write(oprot)
      oprot.writeFieldEnd()
    if self.variance is not None:
      oprot.writeFieldBegin('variance', TType.STRUCT, 4)
      self.variance.write(oprot)
      oprot.writeFieldEnd()
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.STRUCT, 5)
      self.min.write(oprot)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.STRUCT, 6)
      self.max.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 7)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RollupMetrics:
  """
  Attributes:
   - metrics
   - unit
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'metrics', (TType.STRUCT,(RollupMetric, RollupMetric.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'unit', None, None, ), # 2
  )

  def __init__(self, metrics=None, unit=None,):
    self.metrics = metrics
    self.unit = unit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.metrics = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = RollupMetric()
            _elem5.read(iprot)
            self.metrics.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.unit = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RollupMetrics')
    if self.metrics is not None:
      oprot.writeFieldBegin('metrics', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.metrics))
      for iter6 in self.metrics:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unit is not None:
      oprot.writeFieldBegin('unit', TType.STRING, 2)
      oprot.writeString(self.unit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetricInfo:
  """
  Attributes:
   - name
   - unit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'unit', None, None, ), # 2
  )

  def __init__(self, name=None, unit=None,):
    self.name = name
    self.unit = unit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.unit = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetricInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.unit is not None:
      oprot.writeFieldBegin('unit', TType.STRING, 2)
      oprot.writeString(self.unit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CorrelatedStatus:
  """
  Attributes:
   - id
   - collector
   - criteriaState
   - status
   - state
   - monitoringZoneId
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'collector', None, None, ), # 2
    (3, TType.I32, 'criteriaState', None, None, ), # 3
    (4, TType.STRING, 'status', None, None, ), # 4
    (5, TType.I32, 'state', None, None, ), # 5
    (6, TType.STRING, 'monitoringZoneId', None, None, ), # 6
    (7, TType.I64, 'timestamp', None, None, ), # 7
  )

  def __init__(self, id=None, collector=None, criteriaState=None, status=None, state=None, monitoringZoneId=None, timestamp=None,):
    self.id = id
    self.collector = collector
    self.criteriaState = criteriaState
    self.status = status
    self.state = state
    self.monitoringZoneId = monitoringZoneId
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collector = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.criteriaState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.monitoringZoneId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CorrelatedStatus')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.collector is not None:
      oprot.writeFieldBegin('collector', TType.STRING, 2)
      oprot.writeString(self.collector)
      oprot.writeFieldEnd()
    if self.criteriaState is not None:
      oprot.writeFieldBegin('criteriaState', TType.I32, 3)
      oprot.writeI32(self.criteriaState)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRING, 4)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 5)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.monitoringZoneId is not None:
      oprot.writeFieldBegin('monitoringZoneId', TType.STRING, 6)
      oprot.writeString(self.monitoringZoneId)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 7)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Telescope:
  """
  Attributes:
   - id
   - checkId
   - acctId
   - checkModule
   - entityId
   - target
   - timestamp
   - consecutiveTrigger
   - verifyModel
   - analyzedByMonitoringZoneId
   - dimensions
   - metrics
   - dimensionKey
   - collector
   - flapEnum
   - criteriaState
   - computedState
   - alarmId
   - availability
   - state
   - status
   - correlatedStatuses
   - monitoringZoneId
   - txnId
   - checkType
   - previousKnownState
   - collectorKeys
   - period
   - timeout
   - metricsTtls
   - resourceNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'checkId', None, None, ), # 2
    (3, TType.STRING, 'acctId', None, None, ), # 3
    (4, TType.STRING, 'checkModule', None, None, ), # 4
    (5, TType.STRING, 'entityId', None, None, ), # 5
    (6, TType.STRING, 'target', None, None, ), # 6
    (7, TType.I64, 'timestamp', None, None, ), # 7
    (8, TType.I32, 'consecutiveTrigger', None, 1, ), # 8
    (9, TType.I32, 'verifyModel', None, None, ), # 9
    (10, TType.STRING, 'analyzedByMonitoringZoneId', None, None, ), # 10
    (11, TType.MAP, 'dimensions', (TType.STRING,None,TType.STRING,None), None, ), # 11
    (12, TType.MAP, 'metrics', (TType.STRING,None,TType.STRUCT,(Metric, Metric.thrift_spec)), None, ), # 12
    None, # 13
    (14, TType.STRING, 'dimensionKey', None, None, ), # 14
    (15, TType.STRING, 'collector', None, None, ), # 15
    (16, TType.I32, 'flapEnum', None,     0, ), # 16
    (17, TType.I32, 'criteriaState', None, None, ), # 17
    (18, TType.I32, 'computedState', None, None, ), # 18
    (19, TType.STRING, 'alarmId', None, None, ), # 19
    (20, TType.BYTE, 'availability', None, None, ), # 20
    (21, TType.BYTE, 'state', None, None, ), # 21
    (22, TType.STRING, 'status', None, None, ), # 22
    (23, TType.LIST, 'correlatedStatuses', (TType.STRUCT,(CorrelatedStatus, CorrelatedStatus.thrift_spec)), None, ), # 23
    (24, TType.STRING, 'monitoringZoneId', None, None, ), # 24
    (25, TType.STRING, 'txnId', None, None, ), # 25
    (26, TType.STRING, 'checkType', None, None, ), # 26
    (27, TType.I32, 'previousKnownState', None, None, ), # 27
    (28, TType.LIST, 'collectorKeys', (TType.STRING,None), None, ), # 28
    (29, TType.I32, 'period', None, 0, ), # 29
    (30, TType.I32, 'timeout', None, 0, ), # 30
    (31, TType.MAP, 'metricsTtls', (TType.STRING,None,TType.I32,None), None, ), # 31
    (32, TType.LIST, 'resourceNames', (TType.STRING,None), None, ), # 32
  )

  def __init__(self, id=None, checkId=None, acctId=None, checkModule=None, entityId=None, target=None, timestamp=None, consecutiveTrigger=thrift_spec[8][4], verifyModel=None, analyzedByMonitoringZoneId=None, dimensions=None, metrics=None, dimensionKey=None, collector=None, flapEnum=thrift_spec[16][4], criteriaState=None, computedState=None, alarmId=None, availability=None, state=None, status=None, correlatedStatuses=None, monitoringZoneId=None, txnId=None, checkType=None, previousKnownState=None, collectorKeys=None, period=thrift_spec[29][4], timeout=thrift_spec[30][4], metricsTtls=None, resourceNames=None,):
    self.id = id
    self.checkId = checkId
    self.acctId = acctId
    self.checkModule = checkModule
    self.entityId = entityId
    self.target = target
    self.timestamp = timestamp
    self.consecutiveTrigger = consecutiveTrigger
    self.verifyModel = verifyModel
    self.analyzedByMonitoringZoneId = analyzedByMonitoringZoneId
    self.dimensions = dimensions
    self.metrics = metrics
    self.dimensionKey = dimensionKey
    self.collector = collector
    self.flapEnum = flapEnum
    self.criteriaState = criteriaState
    self.computedState = computedState
    self.alarmId = alarmId
    self.availability = availability
    self.state = state
    self.status = status
    self.correlatedStatuses = correlatedStatuses
    self.monitoringZoneId = monitoringZoneId
    self.txnId = txnId
    self.checkType = checkType
    self.previousKnownState = previousKnownState
    self.collectorKeys = collectorKeys
    self.period = period
    self.timeout = timeout
    self.metricsTtls = metricsTtls
    self.resourceNames = resourceNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.checkId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.acctId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.checkModule = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.entityId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.target = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.consecutiveTrigger = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.verifyModel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.analyzedByMonitoringZoneId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.dimensions = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.dimensions[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.metrics = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = Metric()
            _val20.read(iprot)
            self.metrics[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.dimensionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.collector = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          self.flapEnum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I32:
          self.criteriaState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.computedState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BYTE:
          self.availability = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BYTE:
          self.state = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.LIST:
          self.correlatedStatuses = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = CorrelatedStatus()
            _elem26.read(iprot)
            self.correlatedStatuses.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.monitoringZoneId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRING:
          self.txnId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRING:
          self.checkType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.I32:
          self.previousKnownState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.LIST:
          self.collectorKeys = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString();
            self.collectorKeys.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.I32:
          self.period = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.I32:
          self.timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.MAP:
          self.metricsTtls = {}
          (_ktype34, _vtype35, _size33 ) = iprot.readMapBegin() 
          for _i37 in xrange(_size33):
            _key38 = iprot.readString();
            _val39 = iprot.readI32();
            self.metricsTtls[_key38] = _val39
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.LIST:
          self.resourceNames = []
          (_etype43, _size40) = iprot.readListBegin()
          for _i44 in xrange(_size40):
            _elem45 = iprot.readString();
            self.resourceNames.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Telescope')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.checkId is not None:
      oprot.writeFieldBegin('checkId', TType.STRING, 2)
      oprot.writeString(self.checkId)
      oprot.writeFieldEnd()
    if self.acctId is not None:
      oprot.writeFieldBegin('acctId', TType.STRING, 3)
      oprot.writeString(self.acctId)
      oprot.writeFieldEnd()
    if self.checkModule is not None:
      oprot.writeFieldBegin('checkModule', TType.STRING, 4)
      oprot.writeString(self.checkModule)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 5)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRING, 6)
      oprot.writeString(self.target)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 7)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.consecutiveTrigger is not None:
      oprot.writeFieldBegin('consecutiveTrigger', TType.I32, 8)
      oprot.writeI32(self.consecutiveTrigger)
      oprot.writeFieldEnd()
    if self.verifyModel is not None:
      oprot.writeFieldBegin('verifyModel', TType.I32, 9)
      oprot.writeI32(self.verifyModel)
      oprot.writeFieldEnd()
    if self.analyzedByMonitoringZoneId is not None:
      oprot.writeFieldBegin('analyzedByMonitoringZoneId', TType.STRING, 10)
      oprot.writeString(self.analyzedByMonitoringZoneId)
      oprot.writeFieldEnd()
    if self.dimensions is not None:
      oprot.writeFieldBegin('dimensions', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.dimensions))
      for kiter46,viter47 in self.dimensions.items():
        oprot.writeString(kiter46)
        oprot.writeString(viter47)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.metrics is not None:
      oprot.writeFieldBegin('metrics', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.metrics))
      for kiter48,viter49 in self.metrics.items():
        oprot.writeString(kiter48)
        viter49.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.dimensionKey is not None:
      oprot.writeFieldBegin('dimensionKey', TType.STRING, 14)
      oprot.writeString(self.dimensionKey)
      oprot.writeFieldEnd()
    if self.collector is not None:
      oprot.writeFieldBegin('collector', TType.STRING, 15)
      oprot.writeString(self.collector)
      oprot.writeFieldEnd()
    if self.flapEnum is not None:
      oprot.writeFieldBegin('flapEnum', TType.I32, 16)
      oprot.writeI32(self.flapEnum)
      oprot.writeFieldEnd()
    if self.criteriaState is not None:
      oprot.writeFieldBegin('criteriaState', TType.I32, 17)
      oprot.writeI32(self.criteriaState)
      oprot.writeFieldEnd()
    if self.computedState is not None:
      oprot.writeFieldBegin('computedState', TType.I32, 18)
      oprot.writeI32(self.computedState)
      oprot.writeFieldEnd()
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 19)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.availability is not None:
      oprot.writeFieldBegin('availability', TType.BYTE, 20)
      oprot.writeByte(self.availability)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.BYTE, 21)
      oprot.writeByte(self.state)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRING, 22)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.correlatedStatuses is not None:
      oprot.writeFieldBegin('correlatedStatuses', TType.LIST, 23)
      oprot.writeListBegin(TType.STRUCT, len(self.correlatedStatuses))
      for iter50 in self.correlatedStatuses:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.monitoringZoneId is not None:
      oprot.writeFieldBegin('monitoringZoneId', TType.STRING, 24)
      oprot.writeString(self.monitoringZoneId)
      oprot.writeFieldEnd()
    if self.txnId is not None:
      oprot.writeFieldBegin('txnId', TType.STRING, 25)
      oprot.writeString(self.txnId)
      oprot.writeFieldEnd()
    if self.checkType is not None:
      oprot.writeFieldBegin('checkType', TType.STRING, 26)
      oprot.writeString(self.checkType)
      oprot.writeFieldEnd()
    if self.previousKnownState is not None:
      oprot.writeFieldBegin('previousKnownState', TType.I32, 27)
      oprot.writeI32(self.previousKnownState)
      oprot.writeFieldEnd()
    if self.collectorKeys is not None:
      oprot.writeFieldBegin('collectorKeys', TType.LIST, 28)
      oprot.writeListBegin(TType.STRING, len(self.collectorKeys))
      for iter51 in self.collectorKeys:
        oprot.writeString(iter51)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.period is not None:
      oprot.writeFieldBegin('period', TType.I32, 29)
      oprot.writeI32(self.period)
      oprot.writeFieldEnd()
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.I32, 30)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.metricsTtls is not None:
      oprot.writeFieldBegin('metricsTtls', TType.MAP, 31)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.metricsTtls))
      for kiter52,viter53 in self.metricsTtls.items():
        oprot.writeString(kiter52)
        oprot.writeI32(viter53)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.resourceNames is not None:
      oprot.writeFieldBegin('resourceNames', TType.LIST, 32)
      oprot.writeListBegin(TType.STRING, len(self.resourceNames))
      for iter54 in self.resourceNames:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RepeatEvent:
  """
  Attributes:
   - alarmId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
  )

  def __init__(self, alarmId=None,):
    self.alarmId = alarmId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RepeatEvent')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CollectorEvent:
  """
  Attributes:
   - collector
   - timestamp
   - availability
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'collector', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.I32, 'availability', None, None, ), # 3
  )

  def __init__(self, collector=None, timestamp=None, availability=None,):
    self.collector = collector
    self.timestamp = timestamp
    self.availability = availability

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.collector = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.availability = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CollectorEvent')
    if self.collector is not None:
      oprot.writeFieldBegin('collector', TType.STRING, 1)
      oprot.writeString(self.collector)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.availability is not None:
      oprot.writeFieldBegin('availability', TType.I32, 3)
      oprot.writeI32(self.availability)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConsecutiveTriggerEvent:
  """
  Attributes:
   - alarmId
   - checkId
   - dimensionKey
   - monitoringZoneId
   - timestamp
   - criteriaState
   - consecutiveEvents
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
    (2, TType.STRING, 'checkId', None, None, ), # 2
    (3, TType.STRING, 'dimensionKey', None, None, ), # 3
    (4, TType.STRING, 'monitoringZoneId', None, None, ), # 4
    (5, TType.I64, 'timestamp', None, None, ), # 5
    (6, TType.I32, 'criteriaState', None, None, ), # 6
    (7, TType.I32, 'consecutiveEvents', None, 0, ), # 7
  )

  def __init__(self, alarmId=None, checkId=None, dimensionKey=None, monitoringZoneId=None, timestamp=None, criteriaState=None, consecutiveEvents=thrift_spec[7][4],):
    self.alarmId = alarmId
    self.checkId = checkId
    self.dimensionKey = dimensionKey
    self.monitoringZoneId = monitoringZoneId
    self.timestamp = timestamp
    self.criteriaState = criteriaState
    self.consecutiveEvents = consecutiveEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.checkId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dimensionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.monitoringZoneId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.criteriaState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.consecutiveEvents = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConsecutiveTriggerEvent')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.checkId is not None:
      oprot.writeFieldBegin('checkId', TType.STRING, 2)
      oprot.writeString(self.checkId)
      oprot.writeFieldEnd()
    if self.dimensionKey is not None:
      oprot.writeFieldBegin('dimensionKey', TType.STRING, 3)
      oprot.writeString(self.dimensionKey)
      oprot.writeFieldEnd()
    if self.monitoringZoneId is not None:
      oprot.writeFieldBegin('monitoringZoneId', TType.STRING, 4)
      oprot.writeString(self.monitoringZoneId)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.criteriaState is not None:
      oprot.writeFieldBegin('criteriaState', TType.I32, 6)
      oprot.writeI32(self.criteriaState)
      oprot.writeFieldEnd()
    if self.consecutiveEvents is not None:
      oprot.writeFieldBegin('consecutiveEvents', TType.I32, 7)
      oprot.writeI32(self.consecutiveEvents)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CollectorTimeout:
  """
  Attributes:
   - timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timeout', None, None, ), # 1
  )

  def __init__(self, timeout=None,):
    self.timeout = timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timeout = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CollectorTimeout')
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.I64, 1)
      oprot.writeI64(self.timeout)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveBoundCheck:
  """
  Attributes:
   - checkId
   - monitoringZoneId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'checkId', None, None, ), # 1
    (2, TType.STRING, 'monitoringZoneId', None, None, ), # 2
  )

  def __init__(self, checkId=None, monitoringZoneId=None,):
    self.checkId = checkId
    self.monitoringZoneId = monitoringZoneId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.checkId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.monitoringZoneId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveBoundCheck')
    if self.checkId is not None:
      oprot.writeFieldBegin('checkId', TType.STRING, 1)
      oprot.writeString(self.checkId)
      oprot.writeFieldEnd()
    if self.monitoringZoneId is not None:
      oprot.writeFieldBegin('monitoringZoneId', TType.STRING, 2)
      oprot.writeString(self.monitoringZoneId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlarmDisableStateUpdate:
  """
  Attributes:
   - acctId
   - entityId
   - alarmId
   - disabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'acctId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.STRING, 'alarmId', None, None, ), # 3
    (4, TType.BOOL, 'disabled', None, None, ), # 4
  )

  def __init__(self, acctId=None, entityId=None, alarmId=None, disabled=None,):
    self.acctId = acctId
    self.entityId = entityId
    self.alarmId = alarmId
    self.disabled = disabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.acctId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.disabled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlarmDisableStateUpdate')
    if self.acctId is not None:
      oprot.writeFieldBegin('acctId', TType.STRING, 1)
      oprot.writeString(self.acctId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 3)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.disabled is not None:
      oprot.writeFieldBegin('disabled', TType.BOOL, 4)
      oprot.writeBool(self.disabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MinimalState:
  """
  Attributes:
   - alarmId
   - dimensionKey
   - checkId
   - computedState
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
    (2, TType.STRING, 'dimensionKey', None, None, ), # 2
    (3, TType.STRING, 'checkId', None, None, ), # 3
    (4, TType.I32, 'computedState', None, None, ), # 4
    (5, TType.I64, 'timestamp', None, None, ), # 5
  )

  def __init__(self, alarmId=None, dimensionKey=None, checkId=None, computedState=None, timestamp=None,):
    self.alarmId = alarmId
    self.dimensionKey = dimensionKey
    self.checkId = checkId
    self.computedState = computedState
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dimensionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.checkId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.computedState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MinimalState')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.dimensionKey is not None:
      oprot.writeFieldBegin('dimensionKey', TType.STRING, 2)
      oprot.writeString(self.dimensionKey)
      oprot.writeFieldEnd()
    if self.checkId is not None:
      oprot.writeFieldBegin('checkId', TType.STRING, 3)
      oprot.writeString(self.checkId)
      oprot.writeFieldEnd()
    if self.computedState is not None:
      oprot.writeFieldBegin('computedState', TType.I32, 4)
      oprot.writeI32(self.computedState)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FlapState:
  """
  Attributes:
   - alarmId
   - dimensionKey
   - checkId
   - flapCalc
   - flapEnum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
    (2, TType.STRING, 'dimensionKey', None, None, ), # 2
    (3, TType.STRING, 'checkId', None, None, ), # 3
    (4, TType.DOUBLE, 'flapCalc', None, None, ), # 4
    (5, TType.I32, 'flapEnum', None, None, ), # 5
  )

  def __init__(self, alarmId=None, dimensionKey=None, checkId=None, flapCalc=None, flapEnum=None,):
    self.alarmId = alarmId
    self.dimensionKey = dimensionKey
    self.checkId = checkId
    self.flapCalc = flapCalc
    self.flapEnum = flapEnum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dimensionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.checkId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.flapCalc = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.flapEnum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FlapState')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.dimensionKey is not None:
      oprot.writeFieldBegin('dimensionKey', TType.STRING, 2)
      oprot.writeString(self.dimensionKey)
      oprot.writeFieldEnd()
    if self.checkId is not None:
      oprot.writeFieldBegin('checkId', TType.STRING, 3)
      oprot.writeString(self.checkId)
      oprot.writeFieldEnd()
    if self.flapCalc is not None:
      oprot.writeFieldBegin('flapCalc', TType.DOUBLE, 4)
      oprot.writeDouble(self.flapCalc)
      oprot.writeFieldEnd()
    if self.flapEnum is not None:
      oprot.writeFieldBegin('flapEnum', TType.I32, 5)
      oprot.writeI32(self.flapEnum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConditionState:
  """
  Attributes:
   - state
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
    (2, TType.STRING, 'message', None, None, ), # 2
  )

  def __init__(self, state=None, message=None,):
    self.state = state
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConditionState')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 2)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TelescopeOrRemove:
  """
  Attributes:
   - telescope
   - bc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'telescope', (Telescope, Telescope.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bc', (RemoveBoundCheck, RemoveBoundCheck.thrift_spec), None, ), # 2
  )

  def __init__(self, telescope=None, bc=None,):
    self.telescope = telescope
    self.bc = bc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.telescope = Telescope()
          self.telescope.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bc = RemoveBoundCheck()
          self.bc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TelescopeOrRemove')
    if self.telescope is not None:
      oprot.writeFieldBegin('telescope', TType.STRUCT, 1)
      self.telescope.write(oprot)
      oprot.writeFieldEnd()
    if self.bc is not None:
      oprot.writeFieldBegin('bc', TType.STRUCT, 2)
      self.bc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AgentTelescope:
  """
  Attributes:
   - error
   - ts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'error', None, None, ), # 1
    (2, TType.LIST, 'ts', (TType.STRUCT,(TelescopeOrRemove, TelescopeOrRemove.thrift_spec)), None, ), # 2
  )

  def __init__(self, error=None, ts=None,):
    self.error = error
    self.ts = ts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.error = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ts = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = TelescopeOrRemove()
            _elem60.read(iprot)
            self.ts.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AgentTelescope')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRING, 1)
      oprot.writeString(self.error)
      oprot.writeFieldEnd()
    if self.ts is not None:
      oprot.writeFieldBegin('ts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.ts))
      for iter61 in self.ts:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
