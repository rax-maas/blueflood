#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def Publish(self, messages):
    """
    Parameters:
     - messages
    """
    pass

  def RepeatEvents(self, repeatEvents):
    """
    Parameters:
     - repeatEvents
    """
    pass

  def RemoveBoundChecks(self, removeBoundChecks):
    """
    Parameters:
     - removeBoundChecks
    """
    pass

  def UpdateCollectorTimeout(self, timeout):
    """
    Parameters:
     - timeout
    """
    pass

  def TestCompileAlarm(self, txnId, query):
    """
    Parameters:
     - txnId
     - query
    """
    pass

  def AddAlarm(self, alarmId, query):
    """
    Parameters:
     - alarmId
     - query
    """
    pass

  def RemoveAlarm(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    pass

  def TestCompileRegexes(self, txnId, regexes):
    """
    Parameters:
     - txnId
     - regexes
    """
    pass

  def GetAlarm(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    pass

  def GetAlarmState(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    pass

  def UpdateAlarmDisabledState(self, acctId, entityId, alarmId, disabled):
    """
    Parameters:
     - acctId
     - entityId
     - alarmId
     - disabled
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def Publish(self, messages):
    """
    Parameters:
     - messages
    """
    self.send_Publish(messages)
    self.recv_Publish()

  def send_Publish(self, messages):
    self._oprot.writeMessageBegin('Publish', TMessageType.CALL, self._seqid)
    args = Publish_args()
    args.messages = messages
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_Publish(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = Publish_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RepeatEvents(self, repeatEvents):
    """
    Parameters:
     - repeatEvents
    """
    self.send_RepeatEvents(repeatEvents)
    self.recv_RepeatEvents()

  def send_RepeatEvents(self, repeatEvents):
    self._oprot.writeMessageBegin('RepeatEvents', TMessageType.CALL, self._seqid)
    args = RepeatEvents_args()
    args.repeatEvents = repeatEvents
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RepeatEvents(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RepeatEvents_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def RemoveBoundChecks(self, removeBoundChecks):
    """
    Parameters:
     - removeBoundChecks
    """
    self.send_RemoveBoundChecks(removeBoundChecks)
    self.recv_RemoveBoundChecks()

  def send_RemoveBoundChecks(self, removeBoundChecks):
    self._oprot.writeMessageBegin('RemoveBoundChecks', TMessageType.CALL, self._seqid)
    args = RemoveBoundChecks_args()
    args.removeBoundChecks = removeBoundChecks
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveBoundChecks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveBoundChecks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def UpdateCollectorTimeout(self, timeout):
    """
    Parameters:
     - timeout
    """
    self.send_UpdateCollectorTimeout(timeout)
    self.recv_UpdateCollectorTimeout()

  def send_UpdateCollectorTimeout(self, timeout):
    self._oprot.writeMessageBegin('UpdateCollectorTimeout', TMessageType.CALL, self._seqid)
    args = UpdateCollectorTimeout_args()
    args.timeout = timeout
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_UpdateCollectorTimeout(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = UpdateCollectorTimeout_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def TestCompileAlarm(self, txnId, query):
    """
    Parameters:
     - txnId
     - query
    """
    self.send_TestCompileAlarm(txnId, query)
    self.recv_TestCompileAlarm()

  def send_TestCompileAlarm(self, txnId, query):
    self._oprot.writeMessageBegin('TestCompileAlarm', TMessageType.CALL, self._seqid)
    args = TestCompileAlarm_args()
    args.txnId = txnId
    args.query = query
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_TestCompileAlarm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = TestCompileAlarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.iqe is not None:
      raise result.iqe
    return

  def AddAlarm(self, alarmId, query):
    """
    Parameters:
     - alarmId
     - query
    """
    self.send_AddAlarm(alarmId, query)
    self.recv_AddAlarm()

  def send_AddAlarm(self, alarmId, query):
    self._oprot.writeMessageBegin('AddAlarm', TMessageType.CALL, self._seqid)
    args = AddAlarm_args()
    args.alarmId = alarmId
    args.query = query
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AddAlarm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AddAlarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.iqe is not None:
      raise result.iqe
    return

  def RemoveAlarm(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    self.send_RemoveAlarm(alarmId)
    self.recv_RemoveAlarm()

  def send_RemoveAlarm(self, alarmId):
    self._oprot.writeMessageBegin('RemoveAlarm', TMessageType.CALL, self._seqid)
    args = RemoveAlarm_args()
    args.alarmId = alarmId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveAlarm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveAlarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.qnfe is not None:
      raise result.qnfe
    return

  def TestCompileRegexes(self, txnId, regexes):
    """
    Parameters:
     - txnId
     - regexes
    """
    self.send_TestCompileRegexes(txnId, regexes)
    self.recv_TestCompileRegexes()

  def send_TestCompileRegexes(self, txnId, regexes):
    self._oprot.writeMessageBegin('TestCompileRegexes', TMessageType.CALL, self._seqid)
    args = TestCompileRegexes_args()
    args.txnId = txnId
    args.regexes = regexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_TestCompileRegexes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = TestCompileRegexes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ire is not None:
      raise result.ire
    return

  def GetAlarm(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    self.send_GetAlarm(alarmId)
    return self.recv_GetAlarm()

  def send_GetAlarm(self, alarmId):
    self._oprot.writeMessageBegin('GetAlarm', TMessageType.CALL, self._seqid)
    args = GetAlarm_args()
    args.alarmId = alarmId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAlarm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAlarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.qnfe is not None:
      raise result.qnfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAlarm failed: unknown result");

  def GetAlarmState(self, alarmId):
    """
    Parameters:
     - alarmId
    """
    self.send_GetAlarmState(alarmId)
    return self.recv_GetAlarmState()

  def send_GetAlarmState(self, alarmId):
    self._oprot.writeMessageBegin('GetAlarmState', TMessageType.CALL, self._seqid)
    args = GetAlarmState_args()
    args.alarmId = alarmId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAlarmState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetAlarmState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.qnfe is not None:
      raise result.qnfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAlarmState failed: unknown result");

  def UpdateAlarmDisabledState(self, acctId, entityId, alarmId, disabled):
    """
    Parameters:
     - acctId
     - entityId
     - alarmId
     - disabled
    """
    self.send_UpdateAlarmDisabledState(acctId, entityId, alarmId, disabled)
    self.recv_UpdateAlarmDisabledState()

  def send_UpdateAlarmDisabledState(self, acctId, entityId, alarmId, disabled):
    self._oprot.writeMessageBegin('UpdateAlarmDisabledState', TMessageType.CALL, self._seqid)
    args = UpdateAlarmDisabledState_args()
    args.acctId = acctId
    args.entityId = entityId
    args.alarmId = alarmId
    args.disabled = disabled
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_UpdateAlarmDisabledState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = UpdateAlarmDisabledState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["Publish"] = Processor.process_Publish
    self._processMap["RepeatEvents"] = Processor.process_RepeatEvents
    self._processMap["RemoveBoundChecks"] = Processor.process_RemoveBoundChecks
    self._processMap["UpdateCollectorTimeout"] = Processor.process_UpdateCollectorTimeout
    self._processMap["TestCompileAlarm"] = Processor.process_TestCompileAlarm
    self._processMap["AddAlarm"] = Processor.process_AddAlarm
    self._processMap["RemoveAlarm"] = Processor.process_RemoveAlarm
    self._processMap["TestCompileRegexes"] = Processor.process_TestCompileRegexes
    self._processMap["GetAlarm"] = Processor.process_GetAlarm
    self._processMap["GetAlarmState"] = Processor.process_GetAlarmState
    self._processMap["UpdateAlarmDisabledState"] = Processor.process_UpdateAlarmDisabledState

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_Publish(self, seqid, iprot, oprot):
    args = Publish_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Publish_result()
    self._handler.Publish(args.messages)
    oprot.writeMessageBegin("Publish", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RepeatEvents(self, seqid, iprot, oprot):
    args = RepeatEvents_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RepeatEvents_result()
    self._handler.RepeatEvents(args.repeatEvents)
    oprot.writeMessageBegin("RepeatEvents", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveBoundChecks(self, seqid, iprot, oprot):
    args = RemoveBoundChecks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveBoundChecks_result()
    self._handler.RemoveBoundChecks(args.removeBoundChecks)
    oprot.writeMessageBegin("RemoveBoundChecks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UpdateCollectorTimeout(self, seqid, iprot, oprot):
    args = UpdateCollectorTimeout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UpdateCollectorTimeout_result()
    self._handler.UpdateCollectorTimeout(args.timeout)
    oprot.writeMessageBegin("UpdateCollectorTimeout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_TestCompileAlarm(self, seqid, iprot, oprot):
    args = TestCompileAlarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = TestCompileAlarm_result()
    try:
      self._handler.TestCompileAlarm(args.txnId, args.query)
    except InvalidQueryException as iqe:
      result.iqe = iqe
    oprot.writeMessageBegin("TestCompileAlarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AddAlarm(self, seqid, iprot, oprot):
    args = AddAlarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AddAlarm_result()
    try:
      self._handler.AddAlarm(args.alarmId, args.query)
    except InvalidQueryException as iqe:
      result.iqe = iqe
    oprot.writeMessageBegin("AddAlarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveAlarm(self, seqid, iprot, oprot):
    args = RemoveAlarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveAlarm_result()
    try:
      self._handler.RemoveAlarm(args.alarmId)
    except AlarmNotFoundException as qnfe:
      result.qnfe = qnfe
    oprot.writeMessageBegin("RemoveAlarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_TestCompileRegexes(self, seqid, iprot, oprot):
    args = TestCompileRegexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = TestCompileRegexes_result()
    try:
      self._handler.TestCompileRegexes(args.txnId, args.regexes)
    except InvalidRegexException as ire:
      result.ire = ire
    oprot.writeMessageBegin("TestCompileRegexes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAlarm(self, seqid, iprot, oprot):
    args = GetAlarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAlarm_result()
    try:
      result.success = self._handler.GetAlarm(args.alarmId)
    except AlarmNotFoundException as qnfe:
      result.qnfe = qnfe
    oprot.writeMessageBegin("GetAlarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAlarmState(self, seqid, iprot, oprot):
    args = GetAlarmState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAlarmState_result()
    try:
      result.success = self._handler.GetAlarmState(args.alarmId)
    except AlarmNotFoundException as qnfe:
      result.qnfe = qnfe
    oprot.writeMessageBegin("GetAlarmState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UpdateAlarmDisabledState(self, seqid, iprot, oprot):
    args = UpdateAlarmDisabledState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UpdateAlarmDisabledState_result()
    self._handler.UpdateAlarmDisabledState(args.acctId, args.entityId, args.alarmId, args.disabled)
    oprot.writeMessageBegin("UpdateAlarmDisabledState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class Publish_args:
  """
  Attributes:
   - messages
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'messages', (TType.STRUCT,(Telescope, Telescope.thrift_spec)), None, ), # 1
  )

  def __init__(self, messages=None,):
    self.messages = messages

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.messages = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = Telescope()
            _elem67.read(iprot)
            self.messages.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Publish_args')
    if self.messages is not None:
      oprot.writeFieldBegin('messages', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.messages))
      for iter68 in self.messages:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Publish_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Publish_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RepeatEvents_args:
  """
  Attributes:
   - repeatEvents
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'repeatEvents', (TType.STRUCT,(RepeatEvent, RepeatEvent.thrift_spec)), None, ), # 1
  )

  def __init__(self, repeatEvents=None,):
    self.repeatEvents = repeatEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.repeatEvents = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = RepeatEvent()
            _elem74.read(iprot)
            self.repeatEvents.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RepeatEvents_args')
    if self.repeatEvents is not None:
      oprot.writeFieldBegin('repeatEvents', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.repeatEvents))
      for iter75 in self.repeatEvents:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RepeatEvents_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RepeatEvents_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveBoundChecks_args:
  """
  Attributes:
   - removeBoundChecks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'removeBoundChecks', (TType.STRUCT,(RemoveBoundCheck, RemoveBoundCheck.thrift_spec)), None, ), # 1
  )

  def __init__(self, removeBoundChecks=None,):
    self.removeBoundChecks = removeBoundChecks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.removeBoundChecks = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = RemoveBoundCheck()
            _elem81.read(iprot)
            self.removeBoundChecks.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveBoundChecks_args')
    if self.removeBoundChecks is not None:
      oprot.writeFieldBegin('removeBoundChecks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.removeBoundChecks))
      for iter82 in self.removeBoundChecks:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveBoundChecks_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveBoundChecks_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateCollectorTimeout_args:
  """
  Attributes:
   - timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'timeout', (CollectorTimeout, CollectorTimeout.thrift_spec), None, ), # 1
  )

  def __init__(self, timeout=None,):
    self.timeout = timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.timeout = CollectorTimeout()
          self.timeout.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateCollectorTimeout_args')
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.STRUCT, 1)
      self.timeout.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateCollectorTimeout_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateCollectorTimeout_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestCompileAlarm_args:
  """
  Attributes:
   - txnId
   - query
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'txnId', None, None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
  )

  def __init__(self, txnId=None, query=None,):
    self.txnId = txnId
    self.query = query

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.txnId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestCompileAlarm_args')
    if self.txnId is not None:
      oprot.writeFieldBegin('txnId', TType.STRING, 1)
      oprot.writeString(self.txnId)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestCompileAlarm_result:
  """
  Attributes:
   - iqe
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'iqe', (InvalidQueryException, InvalidQueryException.thrift_spec), None, ), # 1
  )

  def __init__(self, iqe=None,):
    self.iqe = iqe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.iqe = InvalidQueryException()
          self.iqe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestCompileAlarm_result')
    if self.iqe is not None:
      oprot.writeFieldBegin('iqe', TType.STRUCT, 1)
      self.iqe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAlarm_args:
  """
  Attributes:
   - alarmId
   - query
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
  )

  def __init__(self, alarmId=None, query=None,):
    self.alarmId = alarmId
    self.query = query

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAlarm_args')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddAlarm_result:
  """
  Attributes:
   - iqe
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'iqe', (InvalidQueryException, InvalidQueryException.thrift_spec), None, ), # 1
  )

  def __init__(self, iqe=None,):
    self.iqe = iqe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.iqe = InvalidQueryException()
          self.iqe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddAlarm_result')
    if self.iqe is not None:
      oprot.writeFieldBegin('iqe', TType.STRUCT, 1)
      self.iqe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAlarm_args:
  """
  Attributes:
   - alarmId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
  )

  def __init__(self, alarmId=None,):
    self.alarmId = alarmId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAlarm_args')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveAlarm_result:
  """
  Attributes:
   - qnfe
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'qnfe', (AlarmNotFoundException, AlarmNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, qnfe=None,):
    self.qnfe = qnfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.qnfe = AlarmNotFoundException()
          self.qnfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveAlarm_result')
    if self.qnfe is not None:
      oprot.writeFieldBegin('qnfe', TType.STRUCT, 1)
      self.qnfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestCompileRegexes_args:
  """
  Attributes:
   - txnId
   - regexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'txnId', None, None, ), # 1
    (2, TType.LIST, 'regexes', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, txnId=None, regexes=None,):
    self.txnId = txnId
    self.regexes = regexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.txnId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.regexes = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readString();
            self.regexes.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestCompileRegexes_args')
    if self.txnId is not None:
      oprot.writeFieldBegin('txnId', TType.STRING, 1)
      oprot.writeString(self.txnId)
      oprot.writeFieldEnd()
    if self.regexes is not None:
      oprot.writeFieldBegin('regexes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.regexes))
      for iter89 in self.regexes:
        oprot.writeString(iter89)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TestCompileRegexes_result:
  """
  Attributes:
   - ire
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ire', (InvalidRegexException, InvalidRegexException.thrift_spec), None, ), # 1
  )

  def __init__(self, ire=None,):
    self.ire = ire

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRegexException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TestCompileRegexes_result')
    if self.ire is not None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlarm_args:
  """
  Attributes:
   - alarmId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
  )

  def __init__(self, alarmId=None,):
    self.alarmId = alarmId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlarm_args')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlarm_result:
  """
  Attributes:
   - success
   - qnfe
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'qnfe', (AlarmNotFoundException, AlarmNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, qnfe=None,):
    self.success = success
    self.qnfe = qnfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.qnfe = AlarmNotFoundException()
          self.qnfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlarm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.qnfe is not None:
      oprot.writeFieldBegin('qnfe', TType.STRUCT, 1)
      self.qnfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlarmState_args:
  """
  Attributes:
   - alarmId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'alarmId', None, None, ), # 1
  )

  def __init__(self, alarmId=None,):
    self.alarmId = alarmId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlarmState_args')
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 1)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlarmState_result:
  """
  Attributes:
   - success
   - qnfe
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'qnfe', (AlarmNotFoundException, AlarmNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, qnfe=None,):
    self.success = success
    self.qnfe = qnfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.qnfe = AlarmNotFoundException()
          self.qnfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlarmState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.qnfe is not None:
      oprot.writeFieldBegin('qnfe', TType.STRUCT, 1)
      self.qnfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateAlarmDisabledState_args:
  """
  Attributes:
   - acctId
   - entityId
   - alarmId
   - disabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'acctId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.STRING, 'alarmId', None, None, ), # 3
    (4, TType.BOOL, 'disabled', None, None, ), # 4
  )

  def __init__(self, acctId=None, entityId=None, alarmId=None, disabled=None,):
    self.acctId = acctId
    self.entityId = entityId
    self.alarmId = alarmId
    self.disabled = disabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.acctId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.alarmId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.disabled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateAlarmDisabledState_args')
    if self.acctId is not None:
      oprot.writeFieldBegin('acctId', TType.STRING, 1)
      oprot.writeString(self.acctId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.alarmId is not None:
      oprot.writeFieldBegin('alarmId', TType.STRING, 3)
      oprot.writeString(self.alarmId)
      oprot.writeFieldEnd()
    if self.disabled is not None:
      oprot.writeFieldBegin('disabled', TType.BOOL, 4)
      oprot.writeBool(self.disabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateAlarmDisabledState_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateAlarmDisabledState_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
